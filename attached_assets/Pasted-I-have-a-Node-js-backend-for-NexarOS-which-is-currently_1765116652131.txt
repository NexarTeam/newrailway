I have a Node.js backend for NexarOS which is currently using JSON files as storage (achievements.json, cloud_saves.json, friends.json, messages.json, users.json, wallet_transactions.json, etc.) through utilities like storage.js / utils/fileDb.js.

I’ve now deployed a Postgres database on Railway. On the backend service, I’ve set an environment variable:

DATABASE_URL="postgresql://postgres:RqUespLeigkqQIzCWZIkbltGFOyTYVvC@maglev.proxy.rlwy.net:19922/railway"


I want you to:

1. Add Postgres client (Node pg)

Install the dependency:

Add "pg": "^8.12.0" to dependencies in package.json.

Create a new file at the project root called db.js that uses CommonJS, not TypeScript:

const { Pool } = require("pg");

const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
  ssl: { rejectUnauthorized: false },
});

async function query(text, params) {
  const res = await pool.query(text, params);
  return res;
}

module.exports = { pool, query };


Make sure all imports use require(...) and module.exports, not import / export.

2. Create the initial SQL schema

Create a file sql/initial_schema.sql that defines tables to replace the JSON files we currently use:

-- Users table (replaces users.json)
CREATE TABLE IF NOT EXISTS users (
  id            UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  email         TEXT UNIQUE NOT NULL,
  username      TEXT UNIQUE NOT NULL,
  password_hash TEXT NOT NULL,
  verified      BOOLEAN NOT NULL DEFAULT FALSE,
  created_at    TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Friends list (replaces friends.json)
CREATE TABLE IF NOT EXISTS friends (
  id         UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id    UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  friend_id  UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  status     TEXT NOT NULL DEFAULT 'pending',  -- 'pending' | 'accepted' | 'blocked'
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Messages / chat (replaces messages.json)
CREATE TABLE IF NOT EXISTS messages (
  id          UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  from_user   UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  to_user     UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  content     TEXT NOT NULL,
  created_at  TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Achievements (per user per game, replaces achievements.json)
CREATE TABLE IF NOT EXISTS achievements (
  id          UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id     UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  game_id     TEXT NOT NULL,
  key         TEXT NOT NULL,
  unlocked_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  UNIQUE (user_id, game_id, key)
);

-- Cloud saves (replaces cloud_saves.json)
CREATE TABLE IF NOT EXISTS cloud_saves (
  id          UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id     UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  game_id     TEXT NOT NULL,
  slot        TEXT NOT NULL,
  data        JSONB NOT NULL,
  updated_at  TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  UNIQUE (user_id, game_id, slot)
);

-- Wallet transactions (replaces wallet_transactions.json)
CREATE TABLE IF NOT EXISTS wallet_transactions (
  id            UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id       UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  amount_cents  INTEGER NOT NULL,
  type          TEXT NOT NULL,   -- 'credit' | 'debit'
  source        TEXT NOT NULL,   -- e.g. 'stripe', 'promo', 'refund'
  status        TEXT NOT NULL,   -- 'pending' | 'completed' | 'failed'
  metadata      JSONB,
  created_at    TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

3. Run schema automatically on startup

Create a new helper file initDb.js:

const fs = require("fs");
const path = require("path");
const { query } = require("./db");

async function initDb() {
  const schemaPath = path.join(__dirname, "sql", "initial_schema.sql");
  const sql = fs.readFileSync(schemaPath, "utf8");
  await query(sql);
  console.log("[db] schema ensured");
}

module.exports = { initDb };


In index.js, before starting the HTTP server, import and call this:

const { initDb } = require("./initDb");

(async () => {
  await initDb();
  // existing app + httpServer setup and listen() call goes here
})();


Make sure index.js remains CommonJS (use require, not import).

4. Replace JSON file storage with Postgres

Currently, the backend uses things like storage.js / utils/fileDb.js and the .json files in /data for persistence.

Please:

Open all files that read/write those JSON files (storage.js, utils/fileDb.js, and any helpers under /data usage).

Keep the same function names and signatures that the routes expect (so the API stays compatible), but change their implementation to use the query() function from db.js instead of reading/writing JSON.

For example, wherever users were read from users.json, change to SELECT * FROM users WHERE ....

Writing a new user should do INSERT INTO users ... RETURNING *.

Friends list APIs should operate on the friends table.

Messages APIs should use the messages table, ordered by created_at.

Achievements, cloud saves, and wallet transactions should use the new tables with reasonable mappings from the previous JSON shape.

Remove any unused JSON-file helper functions once Postgres versions exist.

5. Keep everything in plain JavaScript

Make sure:

No TypeScript syntax remains (interface, type, <T>, : string, etc.).

All modules use require / module.exports.

There is no type: "module" in package.json.

When you’re done, ensure the app starts locally (or via Railway logs) without throwing syntax errors or “Cannot find module” errors, and logs something like “NexarOS Backend API serving on port …” and “[db] schema ensured”.

Do NOT change the HTTP API routes’ external behaviour. Just swap the persistence layer under the hood from JSON files to Postgres using the schema above.

If you need to inspect existing code to maintain compatibility, open the relevant files and adjust accordingly.